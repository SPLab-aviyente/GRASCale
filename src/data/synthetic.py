import numpy as np
import networkx as nx
from scipy import linalg
from sklearn.metrics.pairwise import rbf_kernel

def gen_smooth_gs(G, n_signals, filter="Gaussian", alpha=10, noise_amount=0.1):
    """Generate a set of smooth graph signals from a given graph as described in [1].
    Parameters
    ----------
    G : networkx graph
        An undirected networkx graph.
    n_signals : int
        Number of signals to generate.
    filter : str, optional
        The filter to use to generate smooth signals. It can be 'Gaussian', 'Tikhonov' or 'Heat'. 
        See Notes and [1] for further details, by default 'Gaussian' 
    alpha : float, optional
        A positive number used as the parameter for Tikhonov filter and Heat filter, by default 10  
    noise_amount : float, optional
        Amount of the noise to add the graph signals. Amount of the noise determined in L2-sense, 
        that is if x is the clean signal |e|_2/|x|_2 = noise_amount, where e is the additive noise.
        By default 0.1. 
    Returns
    -------
    X : ndarray
        Generated smooth graph signals. Its dimension is (n_nodes, n_signals).
    Notes
    -------
    In [1], smooth graph signals are generated by graph filtering a white noise signal. Let 
    :math:`L = VDV^T` be the eigendecomposition of the graph Laplacian L. A smooth graph signal x is 
    generated by:
    
    .. math:: x = Vh(D)y + e
    where y is the graph Fourier transform of the white noise and e is the additive Gaussian noise.
    h(D) is the graph filter that makes x to be smooth over the graph. See [1] for different forms 
    used for h(D). 
    References
    -------
    .. [1] Kalofolias, Vassilis. "How to learn a graph from smooth signals." Artificial Intelligence
           and Statistics. PMLR, 2016.
    """
    n_nodes = G.number_of_nodes()

    # Get the graph Laplacian spectrum
    L = nx.laplacian_matrix(G).todense()
    e, V = linalg.eigh(L, overwrite_a=True)

    # Normalize the Laplacian such that |L|_2 = 1
    e[e < 1e-8] = 0
    e /= np.max(e)
    
    # Generate signals
    rng = np.random.default_rng()
    X0 = rng.multivariate_normal(np.zeros(n_nodes), np.eye(n_nodes), n_signals).T # White noise
    X0_hat = V.T@X0 # GFT of X0

    # Filtering to generate smooth graph signals from X0
    if filter == "Gaussian":
        h = np.zeros(n_nodes)
        h[e > 0] = 1/np.sqrt(e[e>0])
    elif filter == "Tikhonov":
        h = 1/(1+alpha*e)
    elif filter == "Heat":
        h = np.exp(-alpha*e)

    X = V@np.diag(h)@X0_hat

    # Add noise
    X_norm = np.linalg.norm(X)
    E = rng.normal(0, 1, X.shape)
    E_norm = np.linalg.norm(E)
    X += E*(noise_amount*X_norm/E_norm)

    return X

def gen_smooth_gs_er(n_nodes, p, n_signals, filter="Gaussian", alpha=10, noise_amount=0.1):
    """Generate a set of smooth graph signals from an Erdos-Renyi graph. See `gen_smooth_gs` for how 
    signals are generated.
    Parameters
    ----------
    n_nodes : int
        Number of nodes
    p : float
        Edge probability of the Erdos-Renyi random graph
    n_signals : int
        Number of signals
    filter : str, optional
        The filter to use to generate smooth signals. It can be 'Gaussian', 'Tikhonov' or 'Heat'. 
        See `gen_smooth_gs` for further details, by default 'Gaussian' 
    alpha : float, optional
        A positive number used as the parameter for Tikhonov filter and Heat filter, by default 10  
    noise_amount : float, optional
        Amount of the noise to add the graph signals. Amount of the noise determined in L2-sense, 
        that is if x is the clean signal |e|_2/|x|_2 = noise_amount where e is the additive noise.
        By default 0.1. 
    Returns
    -------
    G : networkx graph
        Generated Erdos-Renyi graph
    X : ndarray
        Generated smooth graph signals. Its dimension is (n_nodes, n_signals).
    """
    G = nx.erdos_renyi_graph(n_nodes, p)
    return G, gen_smooth_gs(G, n_signals, filter, alpha, noise_amount)

def gen_smooth_gs_ba(n_nodes, m, n_signals, filter="Gaussian", alpha=10, noise_amount=0.1):
    """Generate a set of smooth graph signals from an Barabasi-Albert graph. See `gen_smooth_gs` for 
    how signals are generated.
    Parameters
    ----------
    n_nodes : int
        Number of nodes
    m : int
        Number of edges to add at each step of Barabasi-Albert random network generation
    n_signals : int
        Number of signals
    filter : str, optional
        The filter to use to generate smooth signals. It can be 'Gaussian', 'Tikhonov' or 'Heat'. 
        See `gen_smooth_gs` for further details, by default 'Gaussian' 
    alpha : float, optional
        A positive number used as the parameter for Tikhonov filter and Heat filter, by default 10
    noise_amount : float, optional
        Amount of the noise to add the graph signals. Amount of the noise determined in L2-sense, 
        that is if x is the clean signal |e|_2/|x|_2 = noise_amount where e is the additive noise.
        By default 0.1. 
    Returns
    -------
    G : networkx graph
        Generated Barabasi-Albert graph
    X : ndarray
        Generated smooth graph signals. Its dimension is (n_nodes, n_signals).
    """

    G = nx.barabasi_albert_graph(n_nodes, m)
    return G, gen_smooth_gs(G, n_signals, filter, alpha, noise_amount)

def gen_smooth_gs_rgg(n_nodes, std, threshold, n_signals, filter="Gaussian", alpha=10, 
                      noise_amount=0.1):
    """Generate a set of smooth graph signals from an random geometric graph, which is a graph 
    generated from a set of random points drawn uniformly from 2D unit square by adding a weighted 
    edge between each pair of points. Weights are calculated by RBF kernel and those smaller than 
    a value is removed to make the graph sparser. See `gen_smooth_gs` for how signals are generated. 
    Parameters
    ----------
    n_nodes : int
        Number of nodes
    std : float
        Standard deviation of RBF kernel
    threshold : float
        Threshold to remove edges with small weights
    n_signals : int
        Number of signals
    filter : str, optional
        The filter to use to generate smooth signals. It can be 'Gaussian', 'Tikhonov' or 'Heat'. 
        See `gen_smooth_gs` for further details, by default 'Gaussian' 
    alpha : float, optional
        A positive number used as the parameter for Tikhonov filter and Heat filter, by default 10
    noise_amount : float, optional
        Amount of the noise to add the graph signals. Amount of the noise determined in L2-sense, 
        that is if x is the clean signal |e|_2/|x|_2 = noise_amount where e is the additive noise.
        By default 0.1. 
    Returns
    -------
    G : networkx graph
        Generated Barabasi-Albert graph
    X : ndarray
        Generated smooth graph signals. Its dimension is (n_nodes, n_signals).
    """

    # Generate the RGG
    rng = np.random.default_rng()
    points = rng.uniform(-1, 1, size=(n_nodes, 2))
    
    A = rbf_kernel(points, gamma=1/(std**2))
    A[A<threshold] = 0
    A[np.diag_indices_from(A)] = 0
    G = nx.from_numpy_array(A)

    return G, gen_smooth_gs(G, n_signals, filter, alpha, noise_amount)